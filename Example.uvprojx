#include "stm32f10x.h"
#include "stm32f10x_rcc.h"
#include "stm32f10x_gpio.h"
#include "stm32f10x_spi.h"
#include "stm32f10x_usart.h"
#include <stdio.h>
#include <string.h>
#include <stdarg.h>


static volatile uint32_t msTicks = 0;
void SysTick_Handler(void){ msTicks++; }
static void delay_ms(uint32_t ms){
  uint32_t t = msTicks; while ((msTicks - t) < ms) __NOP();
}

#define LCD_DC_PORT   GPIOB
#define LCD_DC_PIN    GPIO_Pin_0
#define LCD_RES_PORT  GPIOB
#define LCD_RES_PIN   GPIO_Pin_1
#define LCD_BLK_PORT  GPIOB
#define LCD_BLK_PIN   GPIO_Pin_10

/* ================= UART1 ================= */
static void UART1_Init(void){
  GPIO_InitTypeDef g; USART_InitTypeDef u;

  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_USART1, ENABLE);

  g.GPIO_Speed = GPIO_Speed_50MHz;

  g.GPIO_Mode = GPIO_Mode_AF_PP;     g.GPIO_Pin = GPIO_Pin_9;  GPIO_Init(GPIOA, &g); // TX
  g.GPIO_Mode = GPIO_Mode_IN_FLOATING; g.GPIO_Pin = GPIO_Pin_10; GPIO_Init(GPIOA, &g); // RX

  u.USART_BaudRate = 115200;
  u.USART_WordLength = USART_WordLength_8b;
  u.USART_StopBits   = USART_StopBits_1;
  u.USART_Parity     = USART_Parity_No;
  u.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
  u.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
  USART_Init(USART1, &u);
  USART_Cmd(USART1, ENABLE);
}
static void uart_putc(char c){
  while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
  USART_SendData(USART1, (uint16_t)c);
}
static void uart_printf(const char *fmt, ...){
  char buf[160]; va_list ap; va_start(ap, fmt);
  vsnprintf(buf, sizeof(buf), fmt, ap); va_end(ap);
  for(char *p=buf; *p; ++p) uart_putc(*p);
}
static int uart_available(void){
  return (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) != RESET);
}
static char uart_getc(void){
  return (char)USART_ReceiveData(USART1);
}

/* ================= SPI1 (Mode 3) ================= */
static void SPI1_Init_Master(void){
  GPIO_InitTypeDef g; SPI_InitTypeDef s;

  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB |
                         RCC_APB2Periph_AFIO | RCC_APB2Periph_SPI1, ENABLE);

  // PA5=SCK, PA7=MOSI
  g.GPIO_Speed = GPIO_Speed_50MHz;
  g.GPIO_Mode  = GPIO_Mode_AF_PP;
  g.GPIO_Pin   = GPIO_Pin_5 | GPIO_Pin_7;
  GPIO_Init(GPIOA, &g);

  // PA6=MISO (không dùng) ? input floating
  g.GPIO_Mode  = GPIO_Mode_IN_FLOATING;
  g.GPIO_Pin   = GPIO_Pin_6;
  GPIO_Init(GPIOA, &g);

  // DC / RES / BLK
  g.GPIO_Mode  = GPIO_Mode_Out_PP;
  g.GPIO_Pin   = LCD_DC_PIN | LCD_RES_PIN | LCD_BLK_PIN;
  GPIO_Init(GPIOB, &g);

  GPIO_SetBits(LCD_BLK_PORT, LCD_BLK_PIN); // bat dèn nen
  GPIO_SetBits(LCD_RES_PORT, LCD_RES_PIN); // RST high

  SPI_I2S_DeInit(SPI1);
  s.SPI_Direction = SPI_Direction_2Lines_FullDuplex; 
  s.SPI_Mode      = SPI_Mode_Master;
  s.SPI_DataSize  = SPI_DataSize_8b;
  s.SPI_CPOL      = SPI_CPOL_High;   
  s.SPI_CPHA      = SPI_CPHA_2Edge;  
  s.SPI_NSS       = SPI_NSS_Soft;   
  s.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8; 
  s.SPI_FirstBit  = SPI_FirstBit_MSB;
  s.SPI_CRCPolynomial = 7;
  SPI_Init(SPI1, &s);
  SPI_Cmd(SPI1, ENABLE);
}
static inline uint8_t SPI1_TxRx(uint8_t b){
  while (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
  SPI_I2S_SendData(SPI1, b);
  while (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
  return (uint8_t)SPI_I2S_ReceiveData(SPI1);
}

/* =============== ST7789 low-level (NO CS) =============== */
static void LCD_WriteCommand(uint8_t cmd){
  GPIO_ResetBits(LCD_DC_PORT, LCD_DC_PIN); // DC=0: command
  SPI1_TxRx(cmd);
}
static void LCD_WriteData(uint8_t data){
  GPIO_SetBits(LCD_DC_PORT, LCD_DC_PIN);   // DC=1: data
  SPI1_TxRx(data);
}
static void LCD_WriteData16(uint16_t d){   // RGB565
  GPIO_SetBits(LCD_DC_PORT, LCD_DC_PIN);
  SPI1_TxRx(d >> 8); SPI1_TxRx(d & 0xFF);
}
static void LCD_SetAddrWindow(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1){
  LCD_WriteCommand(0x2A); // CASET
  LCD_WriteData(x0>>8); LCD_WriteData(x0);
  LCD_WriteData(x1>>8); LCD_WriteData(x1);
  LCD_WriteCommand(0x2B); // RASET
  LCD_WriteData(y0>>8); LCD_WriteData(y0);
  LCD_WriteData(y1>>8); LCD_WriteData(y1);
  LCD_WriteCommand(0x2C); // RAMWR
}
static void LCD_Reset(void){
  GPIO_ResetBits(LCD_RES_PORT, LCD_RES_PIN); delay_ms(10);
  GPIO_SetBits(LCD_RES_PORT, LCD_RES_PIN);   delay_ms(120);
}
static void LCD_Init(void){
  LCD_Reset();
  LCD_WriteCommand(0x11);            // Sleep Out
  delay_ms(120);
  LCD_WriteCommand(0x36); LCD_WriteData(0x00); // MADCTL (0x00 = RGB, 0°)
  LCD_WriteCommand(0x3A); LCD_WriteData(0x55); // 16-bit
  LCD_WriteCommand(0x21);            // Inversion ON (nhi?u module hi?n th? d?p hon)
  LCD_WriteCommand(0x29);            // Display ON
}
static void LCD_FillScreen(uint16_t color){
  LCD_SetAddrWindow(0,0,239,239);
  for (uint32_t i=0; i<240UL*240UL; ++i) LCD_WriteData16(color);
}

/* ===== Font 5x7 rút gon (ASCII 0x20..0x7E) ===== */
static const uint8_t font5x7[] = {
  0x00,0x00,0x00,0x00,0x00, /* SP */
  0x00,0x00,0x5F,0x00,0x00, /* ! */
  0x00,0x03,0x00,0x03,0x00, /* " */
  0x14,0x7F,0x14,0x7F,0x14, /* # */
  0x24,0x2A,0x7F,0x2A,0x12, /* $ */
  0x23,0x13,0x08,0x64,0x62, /* % */
  0x36,0x49,0x55,0x22,0x50, /* & */
  0x00,0x05,0x03,0x00,0x00, /* ' */
  0x00,0x1C,0x22,0x41,0x00, /* ( */
  0x00,0x41,0x22,0x1C,0x00, /* ) */
  0x14,0x08,0x3E,0x08,0x14, /* * */
  0x08,0x08,0x3E,0x08,0x08, /* + */
  0x00,0x50,0x30,0x00,0x00, /* , */
  0x08,0x08,0x08,0x08,0x08, /* - */
  0x00,0x60,0x60,0x00,0x00, /* . */
  0x20,0x10,0x08,0x04,0x02, /* / */
  0x3E,0x51,0x49,0x45,0x3E, /* 0 */
  0x00,0x42,0x7F,0x40,0x00, /* 1 */
  0x42,0x61,0x51,0x49,0x46, /* 2 */
  0x21,0x41,0x45,0x4B,0x31, /* 3 */
  0x18,0x14,0x12,0x7F,0x10, /* 4 */
  0x27,0x45,0x45,0x45,0x39, /* 5 */
  0x3C,0x4A,0x49,0x49,0x30, /* 6 */
  0x01,0x71,0x09,0x05,0x03, /* 7 */
  0x36,0x49,0x49,0x49,0x36, /* 8 */
  0x06,0x49,0x49,0x29,0x1E, /* 9 */
  0x00,0x36,0x36,0x00,0x00, /* : */
  0x00,0x56,0x36,0x00,0x00, /* ; */
  0x08,0x14,0x22,0x41,0x00, /* < */
  0x14,0x14,0x14,0x14,0x14, /* = */
  0x00,0x41,0x22,0x14,0x08, /* > */
  0x02,0x01,0x51,0x09,0x06, /* ? */
  0x32,0x49,0x79,0x41,0x3E, /* @ */
  0x7E,0x11,0x11,0x11,0x7E, /* A */
  0x7F,0x49,0x49,0x49,0x36, /* B */
  0x3E,0x41,0x41,0x41,0x22, /* C */
  0x7F,0x41,0x41,0x22,0x1C, /* D */
  0x7F,0x49,0x49,0x49,0x41, /* E */
  0x7F,0x09,0x09,0x09,0x01, /* F */
  0x3E,0x41,0x49,0x49,0x7A, /* G */
  0x7F,0x08,0x08,0x08,0x7F, /* H */
  0x00,0x41,0x7F,0x41,0x00, /* I */
  0x20,0x40,0x41,0x3F,0x01, /* J */
  0x7F,0x08,0x14,0x22,0x41, /* K */
  0x7F,0x40,0x40,0x40,0x40, /* L */
  0x7F,0x02,0x0C,0x02,0x7F, /* M */
  0x7F,0x04,0x08,0x10,0x7F, /* N */
  0x3E,0x41,0x41,0x41,0x3E, /* O */
  0x7F,0x09,0x09,0x09,0x06, /* P */
  0x3E,0x41,0x51,0x21,0x5E, /* Q */
  0x7F,0x09,0x19,0x29,0x46, /* R */
  0x46,0x49,0x49,0x49,0x31, /* S */
  0x01,0x01,0x7F,0x01,0x01, /* T */
  0x3F,0x40,0x40,0x40,0x3F, /* U */
  0x1F,0x20,0x40,0x20,0x1F, /* V */
  0x7F,0x20,0x18,0x20,0x7F, /* W */
  0x63,0x14,0x08,0x14,0x63, /* X */
  0x07,0x08,0x70,0x08,0x07, /* Y */
  0x61,0x51,0x49,0x45,0x43, /* Z */
  0x00,0x7F,0x41,0x41,0x00, /* [ */
  0x02,0x04,0x08,0x10,0x20, /* \ */
  0x00,0x41,0x41,0x7F,0x00, /* ] */
  0x04,0x02,0x01,0x02,0x04, /* ^ */
  0x40,0x40,0x40,0x40,0x40, /* _ */
  0x00,0x01,0x02,0x00,0x00, /* ` */
  0x20,0x54,0x54,0x54,0x78, /* a */
  0x7F,0x48,0x44,0x44,0x38, /* b */
  0x38,0x44,0x44,0x44,0x20, /* c */
  0x38,0x44,0x44,0x48,0x7F, /* d */
  0x38,0x54,0x54,0x54,0x18, /* e */
  0x08,0x7E,0x09,0x01,0x02, /* f */
  0x0C,0x52,0x52,0x52,0x3E, /* g */
  0x7F,0x08,0x04,0x04,0x78, /* h */
  0x00,0x44,0x7D,0x40,0x00, /* i */
  0x20,0x40,0x44,0x3D,0x00, /* j */
  0x7F,0x10,0x28,0x44,0x00, /* k */
  0x00,0x41,0x7F,0x40,0x00, /* l */
  0x7C,0x04,0x18,0x04,0x78, /* m */
  0x7C,0x08,0x04,0x04,0x78, /* n */
  0x38,0x44,0x44,0x44,0x38, /* o */
  0x7C,0x14,0x14,0x14,0x08, /* p */
  0x08,0x14,0x14,0x18,0x7C, /* q */
  0x7C,0x08,0x04,0x04,0x08, /* r */
  0x48,0x54,0x54,0x54,0x20, /* s */
  0x04,0x3F,0x44,0x40,0x20, /* t */
  0x3C,0x40,0x40,0x20,0x7C, /* u */
  0x1C,0x20,0x40,0x20,0x1C, /* v */
  0x3C,0x40,0x30,0x40,0x3C, /* w */
  0x44,0x28,0x10,0x28,0x44, /* x */
  0x0C,0x50,0x50,0x50,0x3C, /* y */
  0x44,0x64,0x54,0x4C,0x44, /* z */
  0x00,0x08,0x36,0x41,0x00, /* { */
  0x00,0x00,0x7F,0x00,0x00, /* | */
  0x00,0x41,0x36,0x08,0x00, /* } */
  0x08,0x04,0x08,0x10,0x08  /* ~ */
};

static void LCD_DrawChar5x7(uint16_t x, uint16_t y, char c, uint16_t fg, uint16_t bg){
  if (c < 0x20 || c > 0x7E) c = '?';
  for (uint8_t col=0; col<5; col++){
    uint8_t bits = font5x7[(c-0x20)*5 + col];
    for (uint8_t row=0; row<8; row++){
      uint16_t color = (bits & (1<<row)) ? fg : bg;
      if (x+col < 240 && y+row < 240){
        LCD_SetAddrWindow(x+col, y+row, x+col, y+row);
        LCD_WriteData16(color);
      }
    }
  }
  if (x+5 < 240){
    for (uint8_t row=0; row<8; row++){
      LCD_SetAddrWindow(x+5, y+row, x+5, y+row);
      LCD_WriteData16(bg);
    }
  }
}
static void LCD_DrawString(uint16_t x, uint16_t y, const char* s, uint16_t fg, uint16_t bg){
  while (*s){
    if (*s=='\n'){ y+=8; x=0; s++; continue; }
    if (x+6 > 240){ y+=8; x=0; }
    if (y+8 > 240) break;
    LCD_DrawChar5x7(x, y, *s++, fg, bg);
    x += 6;
  }
}

int main(void){
  SystemInit();
  SysTick_Config(SystemCoreClock/1000);

  UART1_Init();
  SPI1_Init_Master();

  uart_printf("\r\n== STM32F103 + ST7789 (SPI write-only) + UART ==\r\n");

  LCD_Init();
  LCD_FillScreen(0x0000); // n?n den
  LCD_DrawString(4, 4, "Ready. Type text and press Enter...", 0xFFFF, 0x0000);

  char line[128]; uint8_t idx=0; uint16_t y=20;

  while (1){
    if (uart_available()){
      char c = uart_getc(); uart_putc(c); // echo ra terminal
      if (c=='\r' || c=='\n'){
        line[idx] = '\0';
        if (y > 232){ LCD_FillScreen(0x0000); y = 4; }
        LCD_DrawString(4, y, line, 0x07E0 /*green*/, 0x0000 /*black*/);
        y += 10; idx = 0;
      } else {
        if (idx < sizeof(line)-1) line[idx++] = c;
      }
    }
  }
}
